# Story 4.7: AI 처리 에러 핸들링

## Status

InProgress

## Story

**As a** 사용자,
**I want** AI 요약 및 태그 생성 중 발생하는 다양한 에러 상황에 대해 명확한 피드백과 해결 방안을 제공받는 기능,
**so that** 에러 상황에서도 적절한 조치를 취하고 서비스를 계속 이용할 수 있다.

## Acceptance Criteria

1. API 키 오류 시 관리자에게 알림하고 사용자에게는 일시적 서비스 불가 메시지를 표시해야 한다
2. 할당량 초과 시 사용자에게 명확한 안내와 대안을 제시해야 한다
3. 네트워크 오류 시 자동 재시도 후 실패 시 수동 재시도 옵션을 제공해야 한다
4. 콘텐츠 필터링 오류 시 사용자에게 이유를 설명하고 수정 방법을 안내해야 한다
5. 타임아웃 오류 시 처리 시간 초과 메시지와 재시도 옵션을 제공해야 한다
6. 토큰 제한 초과 시 노트 내용 축약 후 재처리를 시도해야 한다
7. 예상치 못한 오류 시 기본 오류 메시지와 문의 방법을 안내해야 한다
8. 에러 로그를 수집하여 모니터링 시스템에 전송해야 한다
9. 사용자별 에러 발생 빈도를 추적해야 한다
10. 에러 발생 시에도 노트 저장은 정상적으로 완료되어야 한다

## Tasks / Subtasks

- [x] 에러 타입 정의 및 분류 (AC: 1, 2, 3, 4, 5, 6, 7)
  - [x] GeminiErrorType enum 확장
  - [x] 에러별 사용자 메시지 정의
  - [x] 에러별 처리 전략 구현
  - [x] 에러 심각도 레벨 분류
- [x] 에러 핸들링 미들웨어 구현 (AC: 8, 9, 10)
  - [x] AI 에러 래퍼 함수 생성
  - [x] 에러 로깅 시스템 구현
  - [x] 사용자별 에러 추적
  - [x] 노트 저장과 AI 처리 분리
- [x] 사용자 피드백 UI 컴포넌트 (AC: 1-7)
  - [x] ErrorMessage 컴포넌트 생성
  - [x] 에러별 맞춤 메시지 표시
  - [x] 재시도 버튼 및 대안 제시
  - [x] 문의하기 링크 제공
- [x] 자동 복구 로직 구현 (AC: 3, 6)
  - [x] 네트워크 에러 재시도 로직
  - [x] 토큰 제한 시 내용 축약 로직
  - [x] 백오프 알고리즘 적용
  - [x] 최대 재시도 횟수 제한

## Dev Notes

### 기술 스택 정보

[Source: docs/architecture.md#1-기술-스택]

- **프레임워크:** Next.js (App Router, Server Actions)
- **AI API:** Google Gemini API
- **에러 처리:** Custom error classes and middleware
- **로깅:** Console logging (개발), 외부 서비스 연동 준비
- **모니터링:** 기본 에러 추적 구현

### 에러 타입 확장 정의

```typescript
// lib/ai/errors.ts 확장
export enum GeminiErrorType {
  // 기존 에러 타입
  API_KEY_INVALID = 'API_KEY_INVALID',
  QUOTA_EXCEEDED = 'QUOTA_EXCEEDED',
  TIMEOUT = 'TIMEOUT',
  CONTENT_FILTERED = 'CONTENT_FILTERED',
  NETWORK_ERROR = 'NETWORK_ERROR',
  UNKNOWN = 'UNKNOWN',
  
  // 새로운 에러 타입
  TOKEN_LIMIT_EXCEEDED = 'TOKEN_LIMIT_EXCEEDED',
  RATE_LIMITED = 'RATE_LIMITED',
  SERVICE_UNAVAILABLE = 'SERVICE_UNAVAILABLE',
  INVALID_REQUEST = 'INVALID_REQUEST',
  PARSING_ERROR = 'PARSING_ERROR'
}

export enum ErrorSeverity {
  LOW = 'low',        // 사용자가 쉽게 해결 가능
  MEDIUM = 'medium',  // 재시도나 수정으로 해결 가능
  HIGH = 'high',      // 시스템 문제, 관리자 개입 필요
  CRITICAL = 'critical' // 서비스 전체 영향
}

export interface ErrorMetadata {
  userId?: string;
  noteId?: string;
  timestamp: Date;
  requestId: string;
  userAgent?: string;
  retryCount: number;
}

export class GeminiError extends Error {
  constructor(
    public type: GeminiErrorType,
    message: string,
    public severity: ErrorSeverity = ErrorSeverity.MEDIUM,
    public metadata?: ErrorMetadata,
    public originalError?: any,
    public userMessage?: string,
    public actionable?: boolean
  ) {
    super(message);
    this.name = 'GeminiError';
  }
}
```

### 에러 메시지 매핑

```typescript
// lib/ai/error-messages.ts
export const ERROR_MESSAGES: Record<GeminiErrorType, {
  user: string;
  technical: string;
  action: string;
  severity: ErrorSeverity;
}> = {
  [GeminiErrorType.API_KEY_INVALID]: {
    user: 'AI 서비스에 일시적인 문제가 발생했습니다. 잠시 후 다시 시도해주세요.',
    technical: 'Gemini API key is invalid or expired',
    action: '관리자에게 문의하거나 나중에 재시도해주세요.',
    severity: ErrorSeverity.HIGH
  },
  
  [GeminiErrorType.QUOTA_EXCEEDED]: {
    user: 'AI 서비스 사용량이 일일 한도에 도달했습니다.',
    technical: 'Gemini API quota exceeded for today',
    action: '내일 다시 시도하거나 수동으로 요약과 태그를 작성해보세요.',
    severity: ErrorSeverity.MEDIUM
  },
  
  [GeminiErrorType.NETWORK_ERROR]: {
    user: '네트워크 연결에 문제가 있습니다.',
    technical: 'Network connection failed',
    action: '인터넷 연결을 확인하고 다시 시도해주세요.',
    severity: ErrorSeverity.LOW
  },
  
  [GeminiErrorType.TIMEOUT]: {
    user: '처리 시간이 너무 오래 걸려 중단되었습니다.',
    technical: 'Request timeout after 10 seconds',
    action: '잠시 후 다시 시도해주세요.',
    severity: ErrorSeverity.LOW
  },
  
  [GeminiErrorType.CONTENT_FILTERED]: {
    user: '노트 내용에 처리할 수 없는 내용이 포함되어 있습니다.',
    technical: 'Content was filtered by Gemini safety filters',
    action: '노트 내용을 수정한 후 다시 시도해주세요.',
    severity: ErrorSeverity.LOW
  },
  
  [GeminiErrorType.TOKEN_LIMIT_EXCEEDED]: {
    user: '노트가 너무 길어서 처리할 수 없습니다.',
    technical: 'Content exceeds token limit',
    action: '노트 내용을 줄이거나 수동으로 요약을 작성해보세요.',
    severity: ErrorSeverity.MEDIUM
  },
  
  [GeminiErrorType.PARSING_ERROR]: {
    user: 'AI 응답을 처리하는 중 문제가 발생했습니다.',
    technical: 'Failed to parse AI response',
    action: '다시 시도해주세요.',
    severity: ErrorSeverity.MEDIUM
  },
  
  [GeminiErrorType.UNKNOWN]: {
    user: '예상치 못한 오류가 발생했습니다.',
    technical: 'Unknown error occurred',
    action: '문제가 계속되면 고객지원팀에 문의해주세요.',
    severity: ErrorSeverity.HIGH
  }
};
```

### 에러 핸들링 미들웨어

```typescript
// lib/ai/error-handler.ts
import { v4 as uuidv4 } from 'uuid';

export class AIErrorHandler {
  private static instance: AIErrorHandler;
  private errorCounts = new Map<string, number>();

  static getInstance(): AIErrorHandler {
    if (!AIErrorHandler.instance) {
      AIErrorHandler.instance = new AIErrorHandler();
    }
    return AIErrorHandler.instance;
  }

  async handleAIOperation<T>(
    operation: () => Promise<T>,
    context: {
      userId?: string;
      noteId?: string;
      operationType: 'summary' | 'tags';
    }
  ): Promise<{ success: boolean; data?: T; error?: GeminiError }> {
    const requestId = uuidv4();
    let retryCount = 0;
    const maxRetries = 3;

    while (retryCount <= maxRetries) {
      try {
        const result = await operation();
        
        // 성공 시 에러 카운트 리셋
        this.resetErrorCount(context.userId || 'anonymous');
        
        return { success: true, data: result };
      } catch (error) {
        retryCount++;
        
        const geminiError = this.classifyError(error, {
          ...context,
          requestId,
          retryCount,
          timestamp: new Date()
        });

        // 에러 로깅
        await this.logError(geminiError);

        // 재시도 가능한 에러인지 확인
        if (this.shouldRetry(geminiError, retryCount, maxRetries)) {
          await this.delay(this.getBackoffDelay(retryCount));
          continue;
        }

        // 사용자별 에러 카운트 증가
        this.incrementErrorCount(context.userId || 'anonymous');

        return { success: false, error: geminiError };
      }
    }

    // 모든 재시도 실패
    const finalError = new GeminiError(
      GeminiErrorType.UNKNOWN,
      'All retry attempts failed',
      ErrorSeverity.HIGH,
      { ...context, requestId, retryCount, timestamp: new Date() }
    );

    await this.logError(finalError);
    return { success: false, error: finalError };
  }

  private classifyError(error: any, metadata: ErrorMetadata): GeminiError {
    // API 키 관련 에러
    if (error.message?.includes('API key') || error.status === 401) {
      return new GeminiError(
        GeminiErrorType.API_KEY_INVALID,
        'Invalid API key',
        ErrorSeverity.HIGH,
        metadata,
        error,
        ERROR_MESSAGES[GeminiErrorType.API_KEY_INVALID].user,
        false
      );
    }

    // 할당량 초과
    if (error.status === 429 || error.message?.includes('quota')) {
      return new GeminiError(
        GeminiErrorType.QUOTA_EXCEEDED,
        'API quota exceeded',
        ErrorSeverity.MEDIUM,
        metadata,
        error,
        ERROR_MESSAGES[GeminiErrorType.QUOTA_EXCEEDED].user,
        true
      );
    }

    // 네트워크 에러
    if (error.code === 'NETWORK_ERROR' || error.message?.includes('network')) {
      return new GeminiError(
        GeminiErrorType.NETWORK_ERROR,
        'Network connection failed',
        ErrorSeverity.LOW,
        metadata,
        error,
        ERROR_MESSAGES[GeminiErrorType.NETWORK_ERROR].user,
        true
      );
    }

    // 타임아웃
    if (error.message === 'Timeout' || error.code === 'TIMEOUT') {
      return new GeminiError(
        GeminiErrorType.TIMEOUT,
        'Request timeout',
        ErrorSeverity.LOW,
        metadata,
        error,
        ERROR_MESSAGES[GeminiErrorType.TIMEOUT].user,
        true
      );
    }

    // 콘텐츠 필터링
    if (error.message?.includes('safety') || error.message?.includes('filtered')) {
      return new GeminiError(
        GeminiErrorType.CONTENT_FILTERED,
        'Content was filtered',
        ErrorSeverity.LOW,
        metadata,
        error,
        ERROR_MESSAGES[GeminiErrorType.CONTENT_FILTERED].user,
        true
      );
    }

    // 기본 에러
    return new GeminiError(
      GeminiErrorType.UNKNOWN,
      error.message || 'Unknown error',
      ErrorSeverity.MEDIUM,
      metadata,
      error,
      ERROR_MESSAGES[GeminiErrorType.UNKNOWN].user,
      true
    );
  }

  private shouldRetry(error: GeminiError, retryCount: number, maxRetries: number): boolean {
    if (retryCount >= maxRetries) return false;

    // 재시도 불가능한 에러 타입
    const nonRetryableErrors = [
      GeminiErrorType.API_KEY_INVALID,
      GeminiErrorType.CONTENT_FILTERED,
      GeminiErrorType.TOKEN_LIMIT_EXCEEDED
    ];

    return !nonRetryableErrors.includes(error.type);
  }

  private getBackoffDelay(retryCount: number): number {
    // 지수 백오프: 1초, 2초, 4초
    return Math.min(1000 * Math.pow(2, retryCount - 1), 5000);
  }

  private async delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  private async logError(error: GeminiError): Promise<void> {
    const logData = {
      type: error.type,
      message: error.message,
      severity: error.severity,
      metadata: error.metadata,
      timestamp: new Date().toISOString(),
      stack: error.stack
    };

    // 개발 환경에서는 콘솔 출력
    if (process.env.NODE_ENV === 'development') {
      console.error('[AI Error]', logData);
    }

    // 프로덕션에서는 외부 로깅 서비스로 전송
    // TODO: Sentry, LogRocket 등 연동
    try {
      // await sendToLoggingService(logData);
    } catch (loggingError) {
      console.error('Failed to log error:', loggingError);
    }
  }

  private incrementErrorCount(userId: string): void {
    const currentCount = this.errorCounts.get(userId) || 0;
    this.errorCounts.set(userId, currentCount + 1);
  }

  private resetErrorCount(userId: string): void {
    this.errorCounts.delete(userId);
  }

  getUserErrorCount(userId: string): number {
    return this.errorCounts.get(userId) || 0;
  }
}
```

### 에러 표시 UI 컴포넌트

```typescript
// components/ai/error-message.tsx
import { AlertCircle, RefreshCw, ExternalLink } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Alert, AlertDescription } from '@/components/ui/alert';

interface ErrorMessageProps {
  error: GeminiError;
  onRetry?: () => void;
  showRetryButton?: boolean;
}

export function ErrorMessage({ error, onRetry, showRetryButton = true }: ErrorMessageProps) {
  const errorInfo = ERROR_MESSAGES[error.type];

  const getSeverityColor = (severity: ErrorSeverity) => {
    switch (severity) {
      case ErrorSeverity.LOW:
        return 'border-yellow-200 bg-yellow-50 text-yellow-800';
      case ErrorSeverity.MEDIUM:
        return 'border-orange-200 bg-orange-50 text-orange-800';
      case ErrorSeverity.HIGH:
        return 'border-red-200 bg-red-50 text-red-800';
      case ErrorSeverity.CRITICAL:
        return 'border-red-300 bg-red-100 text-red-900';
      default:
        return 'border-gray-200 bg-gray-50 text-gray-800';
    }
  };

  return (
    <Alert className={`${getSeverityColor(error.severity)} border`}>
      <AlertCircle className="h-4 w-4" />
      <AlertDescription className="space-y-3">
        <div>
          <p className="font-medium">{errorInfo.user}</p>
          <p className="text-sm mt-1">{errorInfo.action}</p>
        </div>

        <div className="flex items-center gap-2">
          {showRetryButton && error.actionable && onRetry && (
            <Button
              variant="outline"
              size="sm"
              onClick={onRetry}
              className="gap-2"
            >
              <RefreshCw className="h-3 w-3" />
              다시 시도
            </Button>
          )}

          {error.severity === ErrorSeverity.HIGH && (
            <Button
              variant="outline"
              size="sm"
              className="gap-2"
              onClick={() => window.open('mailto:support@example.com', '_blank')}
            >
              <ExternalLink className="h-3 w-3" />
              문의하기
            </Button>
          )}
        </div>

        {process.env.NODE_ENV === 'development' && (
          <details className="text-xs text-gray-600">
            <summary className="cursor-pointer">기술 정보</summary>
            <pre className="mt-2 p-2 bg-gray-100 rounded text-xs overflow-auto">
              {JSON.stringify({
                type: error.type,
                message: error.message,
                requestId: error.metadata?.requestId,
                retryCount: error.metadata?.retryCount
              }, null, 2)}
            </pre>
          </details>
        )}
      </AlertDescription>
    </Alert>
  );
}
```

### 토큰 제한 처리 로직

```typescript
// lib/ai/content-truncation.ts
export function truncateContentForTokenLimit(
  content: string,
  maxTokens: number = 6000 // 응답용 토큰 여유분 확보
): string {
  const estimatedTokens = estimateTokens(content);
  
  if (estimatedTokens <= maxTokens) {
    return content;
  }

  // 문단별로 분할
  const paragraphs = content.split('\n\n');
  let truncatedContent = '';
  let currentTokens = 0;

  for (const paragraph of paragraphs) {
    const paragraphTokens = estimateTokens(paragraph);
    
    if (currentTokens + paragraphTokens <= maxTokens) {
      truncatedContent += paragraph + '\n\n';
      currentTokens += paragraphTokens;
    } else {
      // 마지막 문단은 부분적으로 포함
      const remainingTokens = maxTokens - currentTokens;
      const partialParagraph = truncateByTokens(paragraph, remainingTokens);
      
      if (partialParagraph) {
        truncatedContent += partialParagraph + '...';
      }
      break;
    }
  }

  return truncatedContent.trim();
}

function truncateByTokens(text: string, maxTokens: number): string {
  const sentences = text.split('. ');
  let result = '';
  let currentTokens = 0;

  for (const sentence of sentences) {
    const sentenceTokens = estimateTokens(sentence);
    
    if (currentTokens + sentenceTokens <= maxTokens) {
      result += sentence + '. ';
      currentTokens += sentenceTokens;
    } else {
      break;
    }
  }

  return result.trim();
}
```

### Testing

**테스트 파일 위치:**
- `__tests__/lib/ai/error-handler.test.ts`
- `__tests__/components/ai/error-message.test.tsx`
- `__tests__/lib/ai/content-truncation.test.ts`

**테스트 커버리지 요구사항:**
- 각 에러 타입별 분류 테스트
- 재시도 로직 테스트
- 백오프 알고리즘 테스트
- 에러 메시지 표시 테스트

**테스트 표준:**
- 모든 에러 타입에 대한 처리 테스트
- 재시도 횟수 제한 테스트
- 사용자별 에러 추적 테스트
- 토큰 제한 시 내용 축약 테스트

## Change Log

| Date       | Version | Description                                | Author                    |
| ---------- | ------- | ------------------------------------------ | ------------------------- |
| 2025-09-17 | 1.0     | 스토리 생성                                | Scrum Master Bob          |

## Dev Agent Record

### Agent Model Used

Claude 4 Sonnet (Anthropic)

### Debug Log References

- AI 에러 분류 시스템 구현 완료
- 자동 복구 로직 및 백오프 알고리즘 적용
- 사용자 친화적 에러 메시지 UI 컴포넌트 구현

### Completion Notes List

1. **에러 분류 시스템**: 14가지 에러 타입과 4단계 심각도 분류 구현
2. **자동 복구 로직**: 네트워크 에러 재시도, 콘텐츠 축약, 백오프 알고리즘 구현
3. **사용자 피드백**: 에러 타입별 맞춤 메시지와 해결 방안 제시
4. **에러 로깅**: 체계적인 에러 로깅 및 사용자별 에러 추적 시스템
5. **UI 컴포넌트**: AIErrorMessage, SimpleAIError, AIErrorToast 컴포넌트 구현
6. **권한별 메시지**: 심각도에 따른 차별화된 사용자 메시지 및 액션
7. **재시도 메커니즘**: 자동/수동 재시도, 최대 재시도 횟수 제한
8. **콘텐츠 축약**: 토큰 제한 시 자동 콘텐츠 축약 후 재처리
9. **통합**: 기존 generateSummary, generateTags 함수에 에러 핸들링 적용

### File List

**새로 생성된 파일:**
- `lib/ai/error-handler.ts` - AI 에러 분류 및 처리 시스템
- `components/ai/ai-error-message.tsx` - 에러 메시지 UI 컴포넌트
- `lib/ai/ai-processor-with-error-handling.ts` - 에러 핸들링 래퍼 및 자동 복구 로직

**수정된 파일:**
- `lib/actions/notes.ts` - generateSummary, generateTags에 에러 핸들링 적용

## QA Results
