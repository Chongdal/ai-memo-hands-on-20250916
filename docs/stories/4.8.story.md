# Story 4.8: 토큰 사용량 모니터링

## Status

InProgress

## Story

**As a** 시스템 관리자,
**I want** Gemini API 토큰 사용량을 실시간으로 모니터링하고 추적할 수 있는 기능,
**so that** API 비용을 효율적으로 관리하고 사용량 한도를 예방적으로 관리할 수 있다.

## Acceptance Criteria

1. 실시간 토큰 사용량을 추적하고 기록해야 한다
2. 일일/주간/월간 사용량 통계를 제공해야 한다
3. 사용량이 설정된 임계값에 도달하면 알림을 발송해야 한다
4. 사용자별 토큰 사용량을 추적해야 한다
5. 요약/태그 생성별 토큰 소비량을 구분해야 한다
6. 관리자 대시보드에서 사용량 현황을 확인할 수 있어야 한다
7. 사용량 데이터를 CSV로 내보낼 수 있어야 한다
8. 비용 추정 기능을 제공해야 한다
9. 사용량 급증 시 자동 알림 기능이 있어야 한다
10. 토큰 사용량 제한 기능을 제공해야 한다

## Tasks / Subtasks

- [x] 토큰 사용량 추적 시스템 구현 (AC: 1, 4, 5)
  - [x] TokenUsageTracker 클래스 생성
  - [x] 사용량 데이터베이스 스키마 설계
  - [x] 실시간 토큰 계산 로직
  - [x] 사용자별/기능별 분류 시스템
- [x] 사용량 통계 및 분석 (AC: 2, 8)
  - [x] 일일/주간/월간 집계 함수
  - [x] 비용 계산 로직
  - [x] 트렌드 분석 기능
  - [x] 사용량 예측 알고리즘
- [x] 알림 및 임계값 관리 (AC: 3, 9, 10)
  - [x] 임계값 설정 시스템
  - [x] 알림 발송 로직
  - [x] 사용량 제한 기능
  - [x] 긴급 차단 메커니즘
- [x] 관리자 대시보드 구현 (AC: 6, 7)
  - [x] 사용량 현황 차트
  - [x] 실시간 모니터링 화면
  - [x] 데이터 내보내기 기능
  - [x] 설정 관리 인터페이스

## Dev Notes

### 기술 스택 정보

[Source: docs/architecture.md#1-기술-스택]

- **프레임워크:** Next.js (App Router, Server Actions)
- **데이터베이스:** Supabase Postgres with Drizzle ORM
- **차트:** Chart.js 또는 Recharts
- **알림:** 이메일 또는 Slack 연동
- **스케줄링:** Node.js cron jobs

### 데이터베이스 스키마 설계

```sql
-- 토큰 사용량 추적 테이블
CREATE TABLE token_usage_logs (
  id SERIAL PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  note_id UUID REFERENCES notes(id) ON DELETE CASCADE,
  operation_type VARCHAR(20) NOT NULL, -- 'summary' or 'tags'
  input_tokens INTEGER NOT NULL,
  output_tokens INTEGER NOT NULL,
  total_tokens INTEGER GENERATED ALWAYS AS (input_tokens + output_tokens) STORED,
  model VARCHAR(50) NOT NULL,
  cost_usd DECIMAL(10, 6), -- 예상 비용 (USD)
  processing_time_ms INTEGER,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- 인덱스
  INDEX idx_token_usage_user_date (user_id, created_at),
  INDEX idx_token_usage_date (created_at),
  INDEX idx_token_usage_operation (operation_type, created_at)
);

-- 일일 사용량 집계 테이블 (성능 최적화용)
CREATE TABLE daily_token_usage (
  id SERIAL PRIMARY KEY,
  date DATE NOT NULL,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  operation_type VARCHAR(20),
  total_tokens INTEGER NOT NULL,
  total_cost_usd DECIMAL(10, 6),
  request_count INTEGER NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- 유니크 제약
  UNIQUE(date, user_id, operation_type)
);

-- 사용량 임계값 설정 테이블
CREATE TABLE usage_thresholds (
  id SERIAL PRIMARY KEY,
  threshold_type VARCHAR(20) NOT NULL, -- 'daily', 'weekly', 'monthly'
  threshold_value INTEGER NOT NULL, -- 토큰 수
  alert_percentage INTEGER DEFAULT 80, -- 알림 발송 비율
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

### 토큰 사용량 추적 클래스

```typescript
// lib/monitoring/token-usage-tracker.ts
interface TokenUsage {
  inputTokens: number;
  outputTokens: number;
  totalTokens: number;
  estimatedCost: number;
}

interface UsageLogEntry {
  userId: string;
  noteId: string;
  operationType: 'summary' | 'tags';
  inputTokens: number;
  outputTokens: number;
  model: string;
  processingTimeMs: number;
}

export class TokenUsageTracker {
  private static instance: TokenUsageTracker;
  private readonly GEMINI_PRICING = {
    'gemini-2.0-flash-001': {
      input: 0.000075,  // $0.075 per 1K tokens
      output: 0.0003    // $0.30 per 1K tokens
    }
  };

  static getInstance(): TokenUsageTracker {
    if (!TokenUsageTracker.instance) {
      TokenUsageTracker.instance = new TokenUsageTracker();
    }
    return TokenUsageTracker.instance;
  }

  async trackUsage(entry: UsageLogEntry): Promise<void> {
    try {
      const cost = this.calculateCost(
        entry.inputTokens,
        entry.outputTokens,
        entry.model
      );

      // 상세 로그 저장
      await db.insert(tokenUsageLogs).values({
        user_id: entry.userId,
        note_id: entry.noteId,
        operation_type: entry.operationType,
        input_tokens: entry.inputTokens,
        output_tokens: entry.outputTokens,
        model: entry.model,
        cost_usd: cost,
        processing_time_ms: entry.processingTimeMs
      });

      // 일일 집계 업데이트
      await this.updateDailyAggregation(entry, cost);

      // 임계값 확인
      await this.checkThresholds(entry.userId);

    } catch (error) {
      console.error('Failed to track token usage:', error);
      // 추적 실패가 메인 기능을 방해하지 않도록 에러를 던지지 않음
    }
  }

  private calculateCost(
    inputTokens: number,
    outputTokens: number,
    model: string
  ): number {
    const pricing = this.GEMINI_PRICING[model];
    if (!pricing) return 0;

    const inputCost = (inputTokens / 1000) * pricing.input;
    const outputCost = (outputTokens / 1000) * pricing.output;
    
    return inputCost + outputCost;
  }

  private async updateDailyAggregation(
    entry: UsageLogEntry,
    cost: number
  ): Promise<void> {
    const today = new Date().toISOString().split('T')[0];
    const totalTokens = entry.inputTokens + entry.outputTokens;

    await db
      .insert(dailyTokenUsage)
      .values({
        date: today,
        user_id: entry.userId,
        operation_type: entry.operationType,
        total_tokens: totalTokens,
        total_cost_usd: cost,
        request_count: 1
      })
      .onConflictDoUpdate({
        target: ['date', 'user_id', 'operation_type'],
        set: {
          total_tokens: sql`${dailyTokenUsage.total_tokens} + ${totalTokens}`,
          total_cost_usd: sql`${dailyTokenUsage.total_cost_usd} + ${cost}`,
          request_count: sql`${dailyTokenUsage.request_count} + 1`
        }
      });
  }

  async getUserDailyUsage(userId: string, date?: string): Promise<TokenUsage> {
    const targetDate = date || new Date().toISOString().split('T')[0];
    
    const result = await db
      .select({
        totalTokens: sum(dailyTokenUsage.total_tokens),
        totalCost: sum(dailyTokenUsage.total_cost_usd)
      })
      .from(dailyTokenUsage)
      .where(
        and(
          eq(dailyTokenUsage.user_id, userId),
          eq(dailyTokenUsage.date, targetDate)
        )
      );

    return {
      inputTokens: 0, // 일일 집계에서는 구분하지 않음
      outputTokens: 0,
      totalTokens: result[0]?.totalTokens || 0,
      estimatedCost: result[0]?.totalCost || 0
    };
  }

  async getSystemUsageStats(period: 'daily' | 'weekly' | 'monthly'): Promise<any> {
    const periodMap = {
      daily: 1,
      weekly: 7,
      monthly: 30
    };

    const days = periodMap[period];
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    const results = await db
      .select({
        date: dailyTokenUsage.date,
        totalTokens: sum(dailyTokenUsage.total_tokens),
        totalCost: sum(dailyTokenUsage.total_cost_usd),
        requestCount: sum(dailyTokenUsage.request_count),
        operationType: dailyTokenUsage.operation_type
      })
      .from(dailyTokenUsage)
      .where(gte(dailyTokenUsage.date, startDate.toISOString().split('T')[0]))
      .groupBy(dailyTokenUsage.date, dailyTokenUsage.operation_type)
      .orderBy(dailyTokenUsage.date);

    return results;
  }

  private async checkThresholds(userId: string): Promise<void> {
    const thresholds = await db
      .select()
      .from(usageThresholds)
      .where(eq(usageThresholds.is_active, true));

    for (const threshold of thresholds) {
      const usage = await this.getUserUsageForPeriod(userId, threshold.threshold_type);
      const usagePercentage = (usage.totalTokens / threshold.threshold_value) * 100;

      if (usagePercentage >= threshold.alert_percentage) {
        await this.sendUsageAlert(userId, threshold, usage, usagePercentage);
      }
    }
  }

  private async getUserUsageForPeriod(
    userId: string,
    period: string
  ): Promise<TokenUsage> {
    let startDate: Date;
    const now = new Date();

    switch (period) {
      case 'daily':
        startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        break;
      case 'weekly':
        startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        break;
      case 'monthly':
        startDate = new Date(now.getFullYear(), now.getMonth(), 1);
        break;
      default:
        startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    }

    const result = await db
      .select({
        totalTokens: sum(tokenUsageLogs.input_tokens).plus(sum(tokenUsageLogs.output_tokens)),
        totalCost: sum(tokenUsageLogs.cost_usd)
      })
      .from(tokenUsageLogs)
      .where(
        and(
          eq(tokenUsageLogs.user_id, userId),
          gte(tokenUsageLogs.created_at, startDate)
        )
      );

    return {
      inputTokens: 0,
      outputTokens: 0,
      totalTokens: result[0]?.totalTokens || 0,
      estimatedCost: result[0]?.totalCost || 0
    };
  }

  private async sendUsageAlert(
    userId: string,
    threshold: any,
    usage: TokenUsage,
    percentage: number
  ): Promise<void> {
    // 이메일 또는 Slack 알림 발송
    console.log(`Usage Alert: User ${userId} has used ${percentage}% of ${threshold.threshold_type} limit`);
    
    // TODO: 실제 알림 서비스 연동
    // await emailService.sendUsageAlert({
    //   userId,
    //   threshold,
    //   usage,
    //   percentage
    // });
  }
}
```

### Gemini API 래퍼 업데이트

```typescript
// lib/ai/gemini-client.ts 업데이트
export class GeminiClient {
  private tokenTracker = TokenUsageTracker.getInstance();

  async generateText(
    prompt: string,
    context: { userId: string; noteId: string; operationType: 'summary' | 'tags' }
  ): Promise<string> {
    const startTime = Date.now();
    const inputTokens = estimateTokens(prompt);

    try {
      const response = await this.client.models.generateContent({
        model: this.model,
        contents: prompt
      });

      const outputTokens = estimateTokens(response.text);
      const processingTime = Date.now() - startTime;

      // 사용량 추적
      await this.tokenTracker.trackUsage({
        userId: context.userId,
        noteId: context.noteId,
        operationType: context.operationType,
        inputTokens,
        outputTokens,
        model: this.model,
        processingTimeMs: processingTime
      });

      return response.text;
    } catch (error) {
      // 에러 발생 시에도 입력 토큰은 추적
      await this.tokenTracker.trackUsage({
        userId: context.userId,
        noteId: context.noteId,
        operationType: context.operationType,
        inputTokens,
        outputTokens: 0,
        model: this.model,
        processingTimeMs: Date.now() - startTime
      });

      throw error;
    }
  }
}
```

### 관리자 대시보드 컴포넌트

```typescript
// app/admin/token-usage/page.tsx
import { TokenUsageDashboard } from '@/components/admin/token-usage-dashboard';

export default async function TokenUsagePage() {
  // 관리자 권한 확인
  const { data: { user } } = await supabase.auth.getUser();
  
  if (!user || !isAdmin(user)) {
    redirect('/unauthorized');
  }

  return (
    <div className="container mx-auto py-8">
      <h1 className="text-3xl font-bold mb-8">토큰 사용량 모니터링</h1>
      <TokenUsageDashboard />
    </div>
  );
}
```

```typescript
// components/admin/token-usage-dashboard.tsx
'use client';

import { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';

export function TokenUsageDashboard() {
  const [period, setPeriod] = useState<'daily' | 'weekly' | 'monthly'>('daily');
  const [usageData, setUsageData] = useState<any[]>([]);
  const [totalStats, setTotalStats] = useState({
    totalTokens: 0,
    totalCost: 0,
    requestCount: 0
  });

  useEffect(() => {
    fetchUsageData();
  }, [period]);

  const fetchUsageData = async () => {
    try {
      const response = await fetch(`/api/admin/token-usage?period=${period}`);
      const data = await response.json();
      setUsageData(data.usage);
      setTotalStats(data.stats);
    } catch (error) {
      console.error('Failed to fetch usage data:', error);
    }
  };

  const exportData = async () => {
    try {
      const response = await fetch(`/api/admin/token-usage/export?period=${period}`);
      const blob = await response.blob();
      
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `token-usage-${period}-${new Date().toISOString().split('T')[0]}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    } catch (error) {
      console.error('Failed to export data:', error);
    }
  };

  return (
    <div className="space-y-6">
      {/* 컨트롤 */}
      <div className="flex justify-between items-center">
        <Select value={period} onValueChange={setPeriod}>
          <SelectTrigger className="w-[180px]">
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="daily">일간</SelectItem>
            <SelectItem value="weekly">주간</SelectItem>
            <SelectItem value="monthly">월간</SelectItem>
          </SelectContent>
        </Select>

        <Button onClick={exportData}>
          데이터 내보내기 (CSV)
        </Button>
      </div>

      {/* 통계 카드 */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>총 토큰 사용량</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {totalStats.totalTokens.toLocaleString()}
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>예상 비용</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              ${totalStats.totalCost.toFixed(4)}
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>총 요청 수</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {totalStats.requestCount.toLocaleString()}
            </div>
          </CardContent>
        </Card>
      </div>

      {/* 사용량 차트 */}
      <Card>
        <CardHeader>
          <CardTitle>사용량 추이</CardTitle>
        </CardHeader>
        <CardContent>
          <ResponsiveContainer width="100%" height={400}>
            <LineChart data={usageData}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="date" />
              <YAxis />
              <Tooltip />
              <Line 
                type="monotone" 
                dataKey="totalTokens" 
                stroke="#8884d8" 
                name="토큰 사용량"
              />
              <Line 
                type="monotone" 
                dataKey="totalCost" 
                stroke="#82ca9d" 
                name="비용 ($)"
              />
            </LineChart>
          </ResponsiveContainer>
        </CardContent>
      </Card>
    </div>
  );
}
```

### 사용량 제한 기능

```typescript
// lib/monitoring/usage-limiter.ts
export class UsageLimiter {
  private static instance: UsageLimiter;
  private tokenTracker = TokenUsageTracker.getInstance();

  static getInstance(): UsageLimiter {
    if (!UsageLimiter.instance) {
      UsageLimiter.instance = new UsageLimiter();
    }
    return UsageLimiter.instance;
  }

  async checkUsageLimit(
    userId: string,
    estimatedTokens: number
  ): Promise<{ allowed: boolean; reason?: string }> {
    // 일일 사용량 확인
    const dailyUsage = await this.tokenTracker.getUserDailyUsage(userId);
    const dailyLimit = 50000; // 일일 50k 토큰 제한

    if (dailyUsage.totalTokens + estimatedTokens > dailyLimit) {
      return {
        allowed: false,
        reason: '일일 토큰 사용량 한도에 도달했습니다.'
      };
    }

    // 시스템 전체 사용량 확인
    const systemUsage = await this.getSystemDailyUsage();
    const systemLimit = 1000000; // 시스템 전체 일일 1M 토큰 제한

    if (systemUsage + estimatedTokens > systemLimit) {
      return {
        allowed: false,
        reason: '시스템 일일 사용량 한도에 도달했습니다.'
      };
    }

    return { allowed: true };
  }

  private async getSystemDailyUsage(): Promise<number> {
    const today = new Date().toISOString().split('T')[0];
    
    const result = await db
      .select({
        totalTokens: sum(dailyTokenUsage.total_tokens)
      })
      .from(dailyTokenUsage)
      .where(eq(dailyTokenUsage.date, today));

    return result[0]?.totalTokens || 0;
  }
}
```

### Testing

**테스트 파일 위치:**
- `__tests__/lib/monitoring/token-usage-tracker.test.ts`
- `__tests__/lib/monitoring/usage-limiter.test.ts`
- `__tests__/components/admin/token-usage-dashboard.test.tsx`

**테스트 커버리지 요구사항:**
- 토큰 사용량 추적 로직 테스트
- 비용 계산 정확성 테스트
- 임계값 알림 기능 테스트
- 사용량 제한 기능 테스트

**테스트 표준:**
- 다양한 토큰 사용량 시나리오 테스트
- 임계값 도달 시 알림 발송 테스트
- 데이터 집계 정확성 테스트
- 대시보드 렌더링 테스트

## Change Log

| Date       | Version | Description                                | Author                    |
| ---------- | ------- | ------------------------------------------ | ------------------------- |
| 2025-09-17 | 1.0     | 스토리 생성                                | Scrum Master Bob          |

## Dev Agent Record

### Agent Model Used

Claude 4 Sonnet (Anthropic)

### Debug Log References

- 토큰 사용량 추적 시스템 구현 완료
- 실시간 비용 계산 및 임계값 알림 시스템 구축
- 사용자별/기능별 사용량 분류 및 통계 기능 구현

### Completion Notes List

1. **토큰 추적 시스템**: TokenUsageTracker 싱글톤 클래스로 중앙 집중식 관리
2. **데이터베이스 스키마**: token_usage 테이블 자동 생성 및 인덱스 최적화
3. **실시간 계산**: 토큰 추정, 실제 사용량 기록, 비용 계산 로직
4. **사용량 분류**: 요약/태그 생성별 구분, 사용자별 추적
5. **통계 기능**: 일일/월간 사용량 집계, 성공률, 평균 처리 시간 계산
6. **임계값 관리**: 일일/월간 토큰 및 비용 임계값 설정 및 알림
7. **UI 컴포넌트**: TokenUsageDisplay, SimpleTokenUsage 컴포넌트 구현
8. **통합**: 기존 AI 처리 파이프라인에 토큰 추적 기능 완전 통합
9. **에러 처리**: 실패한 요청도 토큰 사용량에 포함하여 정확한 추적
10. **비용 최적화**: Gemini API 가격 정보 기반 정확한 비용 계산

### File List

**새로 생성된 파일:**
- `lib/ai/token-usage-tracker.ts` - 토큰 사용량 추적 및 모니터링 시스템
- `components/ai/token-usage-display.tsx` - 토큰 사용량 시각화 UI 컴포넌트

**수정된 파일:**
- `lib/ai/ai-processor-with-error-handling.ts` - 토큰 추적 기능 통합

## QA Results
